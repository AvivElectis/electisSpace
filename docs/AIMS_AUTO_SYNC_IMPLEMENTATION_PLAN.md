# AIMS Auto-Sync Implementation Plan

> **Status**: Planning Phase  
> **Author**: Generated by GitHub Copilot  
> **Date**: 2026-02-02  

---

## Executive Summary

This document outlines the implementation plan for automatic AIMS synchronization across People, Spaces, and Conference Rooms. The key changes are:

1. **Automatic AIMS sync** - Remove user confirmation checkboxes; entities sync immediately on creation/update
2. **Error rollback** - Revert database changes if AIMS sync fails
3. **Periodic verification** - Server-side job to detect AIMS drift from external changes
4. **Remove manual sync buttons** - "Send All to AIMS" button becomes redundant
5. **Verify CSV upload** - Ensure CSV import properly syncs to AIMS
6. **Validate list management** - Review schema and logic for people lists

---

## Section 1: Current Architecture Analysis

### 1.1 Sync Flow Overview

```
┌─────────────┐     ┌──────────────┐     ┌─────────────────┐     ┌──────────┐
│   Frontend  │────▶│   Backend    │────▶│  SyncQueue      │────▶│   AIMS   │
│   Dialog    │     │   Service    │     │  Processor      │     │   API    │
└─────────────┘     └──────────────┘     └─────────────────┘     └──────────┘
       │                   │                     │
       │                   │                     ▼
       │                   │              ┌─────────────────┐
       │                   └─────────────▶│   PostgreSQL    │
       │                                  │   (persists)    │
       └─────────────────────────────────▶│                 │
           (also direct AIMS via SolumService)              │
                                          └─────────────────┘
```

### 1.2 Current Components

| Component | Location | Purpose |
|-----------|----------|---------|
| `PersonDialog.tsx` | `src/features/people/presentation/` | Add/edit people - has `postToAims` checkbox (line 60) |
| `usePeopleController.ts` | `src/features/people/application/` | People CRUD with optional AIMS sync |
| `PeopleToolbar.tsx` | `src/features/people/presentation/components/` | Has "Send All to AIMS" button (line 75) |
| `PeopleAimsActionsBar.tsx` | `src/features/people/presentation/components/` | Has "Send All to AIMS" button (line 58) |
| `syncQueueService.ts` | `server/src/shared/infrastructure/services/` | Queue CREATE/UPDATE/DELETE operations |
| `SyncQueueProcessor.ts` | `server/src/shared/infrastructure/jobs/` | Background job processing queue |
| `people/service.ts` | `server/src/features/people/` | Backend service - queues sync on create/update |
| `conference/service.ts` | `server/src/features/conference/` | Backend service - queues sync on create/update |

### 1.3 Current Sync Patterns

**People Feature (Frontend-initiated + Backend queue)**:
- `addPersonWithSync()` - Creates in DB, then pushes to AIMS via frontend `SolumService`
- Backend `people/service.ts` also queues to `SyncQueue`
- Dual sync mechanism (frontend direct + backend queue) - needs consolidation

**Conference Rooms (Backend queue only)**:
- Backend `conference/service.ts` creates room → queues to `SyncQueue`
- `SyncQueueProcessor` processes queue → calls `aimsGateway`

**Spaces**:
- Currently no auto-sync in space creation service (needs verification)

---

## Section 2: Implementation Tasks

### 2.1 Remove `postToAims` Checkbox from PersonDialog

**File**: `src/features/people/presentation/PersonDialog.tsx`

**Current State** (lines 60-61):
```tsx
const [postToAims, setPostToAims] = useState(false);
```

**Changes**:
1. Remove `postToAims` state variable
2. Remove the `FormControlLabel` with checkbox (if exists)
3. Remove any conditional logic checking `postToAims`

**Impact**: PersonDialog will always sync to AIMS (via the controller)

---

### 2.2 Update `usePeopleController` for Mandatory Sync

**File**: `src/features/people/application/usePeopleController.ts`

**Changes Required**:

#### 2.2.1 `addPersonWithSync()` (line 790)
- Currently syncs to AIMS - this is correct
- Add rollback logic on AIMS failure:

```typescript
const addPersonWithSync = useCallback(async (personInput: Person | Record<string, string>): Promise<Person> => {
    try {
        // ... existing pool ID logic ...
        
        // Cloud Persistence: Create on Server
        const serverPerson = await getStoreState().createPerson({ ... });
        
        // Immediately sync to AIMS if connected
        if (settings.solumConfig?.tokens?.accessToken) {
            try {
                await pushArticles(...);
                getStoreState().updateSyncStatusLocal([serverPerson.id], 'synced');
            } catch (syncError: any) {
                // ROLLBACK: Delete the person from server
                logger.error('PeopleController', 'AIMS sync failed, rolling back', { error: syncError.message });
                try {
                    await getStoreState().deletePerson(serverPerson.id);
                } catch (deleteError) {
                    logger.error('PeopleController', 'Rollback delete failed', { error: deleteError });
                }
                // Re-throw to inform the user
                throw new Error(`Failed to sync to AIMS: ${syncError.message}. Person was not saved.`);
            }
        }
        return serverPerson;
    } catch (error) { ... }
}, [...]);
```

#### 2.2.2 `updatePersonWithSync()` (line 896)
- Add rollback logic - restore original data on AIMS failure

#### 2.2.3 `deletePersonWithSync()` (line ~950)
- Ensure AIMS delete happens before or atomically with DB delete

#### 2.2.4 Remove parameters with `postToAims: boolean = true`
- `assignSpaceToPerson()` (line 204) - remove parameter, always sync
- `bulkAssignSpaces()` (line 288) - remove parameter, always sync

---

### 2.3 Remove "Send All to AIMS" Button

**Files to modify**:

1. **`PeopleToolbar.tsx`** (lines 75-82)
   - Remove `onSendAllToAims` prop
   - Remove the Send All to AIMS button JSX

2. **`PeopleAimsActionsBar.tsx`** (lines 54-62)
   - Remove `onSendAllToAims` prop  
   - Remove the Send All to AIMS button JSX

3. **`PeopleManagerView.tsx`**
   - Remove `onSendAllToAims` handler passed to toolbars
   - Remove `postAllAssignmentsToAims` import if no longer needed

4. **Locale files**:
   - Keep translations (may be used elsewhere)
   - Consider adding deprecation comments

---

### 2.4 Implement Error Rollback in Backend Service

**Files**: `server/src/features/people/service.ts`, `server/src/features/conference/service.ts`

**Approach**: Transactional pattern with AIMS verification

```typescript
// server/src/features/people/service.ts
async create(input: CreatePersonInput, user: PeopleUserContext) {
    const storeIds = getUserStoreIds(user);
    validateStoreAccess(input.storeId, storeIds);

    // Use transaction for atomicity
    return prisma.$transaction(async (tx) => {
        // Create person in DB
        const person = await tx.person.create({
            data: {
                externalId: input.externalId,
                data: input.data as Prisma.InputJsonValue,
                virtualSpaceId: generateVirtualSpaceId(),
                storeId: input.storeId,
                syncStatus: 'PENDING',
            },
        });

        // Queue sync job (will process asynchronously)
        await syncQueueService.queueCreate(input.storeId, 'person', person.id, input.data);

        return person;
    });
}
```

**Alternative - Synchronous AIMS call with rollback**:
```typescript
async create(input: CreatePersonInput, user: PeopleUserContext) {
    // Create person first
    const person = await peopleRepository.create({ ... });
    
    try {
        // Attempt immediate AIMS sync (blocking)
        await aimsGateway.pushArticles(input.storeId, [buildArticle(person)]);
        
        // Update sync status to SYNCED
        await peopleRepository.update(person.id, { syncStatus: 'SYNCED' });
        
        return person;
    } catch (aimsError) {
        // Rollback: delete the person
        await peopleRepository.delete(person.id);
        
        // Log the error details
        logger.error('PeopleService', 'AIMS sync failed, rolled back person creation', {
            personId: person.id,
            error: aimsError.message,
            stack: aimsError.stack,
        });
        
        throw new Error(`Failed to sync to AIMS: ${aimsError.message}`);
    }
}
```

---

### 2.5 Add Detailed Error Logging

**Create**: `server/src/shared/infrastructure/services/syncErrorLogger.ts`

```typescript
import { prisma } from '../../../config/index.js';

export interface SyncErrorLog {
    storeId: string;
    entityType: 'person' | 'space' | 'conference' | 'list';
    entityId: string;
    action: 'CREATE' | 'UPDATE' | 'DELETE';
    errorMessage: string;
    errorStack?: string;
    requestPayload?: object;
    aimsResponse?: object;
    timestamp: Date;
}

export const syncErrorLogger = {
    async log(error: SyncErrorLog): Promise<void> {
        await prisma.auditLog.create({
            data: {
                storeId: error.storeId,
                action: `AIMS_SYNC_${error.action}_FAILED`,
                entityType: error.entityType,
                entityId: error.entityId,
                newData: {
                    errorMessage: error.errorMessage,
                    errorStack: error.errorStack,
                    requestPayload: error.requestPayload,
                    aimsResponse: error.aimsResponse,
                },
            },
        });
        
        console.error(`[SyncError] ${error.entityType}/${error.entityId}: ${error.errorMessage}`);
    },

    async getRecentErrors(storeId: string, limit = 50): Promise<any[]> {
        return prisma.auditLog.findMany({
            where: {
                storeId,
                action: { startsWith: 'AIMS_SYNC_' },
            },
            orderBy: { createdAt: 'desc' },
            take: limit,
        });
    },
};
```

---

### 2.6 Implement Periodic AIMS Verification

**Create**: `server/src/shared/infrastructure/jobs/AimsVerificationJob.ts`

```typescript
/**
 * AIMS Verification Job
 * 
 * Periodically compares local database state with AIMS to detect drift.
 * Drift can occur when:
 * - External systems modify AIMS directly
 * - Sync failures weren't properly detected
 * - Network issues caused partial updates
 */

import { prisma } from '../../../config/index.js';
import { aimsGateway } from '../services/aimsGateway.js';
import { syncQueueService } from '../services/syncQueueService.js';

const VERIFICATION_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
const BATCH_SIZE = 100;

interface VerificationResult {
    storeId: string;
    entityType: string;
    totalLocal: number;
    totalAims: number;
    missingInAims: string[];
    missingInLocal: string[];
    dataMismatch: string[];
}

export class AimsVerificationJob {
    private isRunning = false;
    private intervalId: ReturnType<typeof setInterval> | null = null;

    start(intervalMs = VERIFICATION_INTERVAL_MS): void {
        if (this.intervalId) {
            console.log('[AimsVerify] Job already running');
            return;
        }

        console.log(`[AimsVerify] Starting verification job with ${intervalMs}ms interval`);
        this.intervalId = setInterval(() => this.tick(), intervalMs);
    }

    stop(): void {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
            console.log('[AimsVerify] Job stopped');
        }
    }

    private async tick(): Promise<void> {
        if (this.isRunning) {
            return;
        }

        this.isRunning = true;
        try {
            await this.verifyAllStores();
        } catch (error) {
            console.error('[AimsVerify] Tick error:', error);
        } finally {
            this.isRunning = false;
        }
    }

    async verifyAllStores(): Promise<VerificationResult[]> {
        const results: VerificationResult[] = [];

        // Get all stores with sync enabled
        const stores = await prisma.store.findMany({
            where: { syncEnabled: true },
            select: { id: true, code: true, companyId: true },
        });

        for (const store of stores) {
            try {
                const result = await this.verifyStore(store.id);
                results.push(result);

                // Queue re-sync for any missing/mismatched entities
                if (result.missingInAims.length > 0) {
                    for (const entityId of result.missingInAims) {
                        await syncQueueService.queueUpdate(
                            store.id,
                            result.entityType as any,
                            entityId,
                            { force: true }
                        );
                    }
                    console.log(`[AimsVerify] Queued ${result.missingInAims.length} entities for re-sync`);
                }
            } catch (error: any) {
                console.error(`[AimsVerify] Failed to verify store ${store.id}:`, error.message);
            }
        }

        return results;
    }

    private async verifyStore(storeId: string): Promise<VerificationResult> {
        // Get local people
        const localPeople = await prisma.person.findMany({
            where: { storeId, syncStatus: 'SYNCED' },
            select: { id: true, externalId: true, virtualSpaceId: true, data: true },
        });

        // Get AIMS articles
        const aimsArticles = await aimsGateway.fetchArticles(storeId);

        // Build lookup maps
        const localByExternalId = new Map(
            localPeople.map(p => [p.externalId || p.virtualSpaceId, p])
        );
        const aimsById = new Map(
            aimsArticles.map(a => [a.articleId || a.id, a])
        );

        // Find discrepancies
        const missingInAims: string[] = [];
        const dataMismatch: string[] = [];

        for (const [extId, person] of localByExternalId) {
            if (!aimsById.has(extId)) {
                missingInAims.push(person.id);
            } else {
                // Compare data (simplified - may need field-by-field comparison)
                const aimsData = aimsById.get(extId);
                // Add data comparison logic here
            }
        }

        const missingInLocal = Array.from(aimsById.keys())
            .filter(id => !localByExternalId.has(id));

        return {
            storeId,
            entityType: 'person',
            totalLocal: localPeople.length,
            totalAims: aimsArticles.length,
            missingInAims,
            missingInLocal,
            dataMismatch,
        };
    }
}

export const aimsVerificationJob = new AimsVerificationJob();
```

**Register in server startup** (`server/src/index.ts`):
```typescript
import { aimsVerificationJob } from './shared/infrastructure/jobs/AimsVerificationJob.js';

// After server starts
aimsVerificationJob.start(5 * 60 * 1000); // Every 5 minutes
```

---

### 2.7 Verify CSV Upload Functionality

**File**: `src/features/people/presentation/CSVUploadDialog.tsx`

**Current Flow**:
1. User selects CSV file
2. `handleImport()` calls `peopleController.loadPeopleFromContent(fileContent)`
3. `loadPeopleFromContent()` parses CSV → generates UUIDs/pool IDs → adds to store

**Verification Checklist**:
- [ ] CSV parsing handles all expected columns
- [ ] Global fields are excluded from CSV columns
- [ ] Pool IDs are correctly reused from AIMS if available
- [ ] Each person is saved to server DB via `createPerson()`
- [ ] Each person is synced to AIMS via `pushArticles()`
- [ ] Error handling shows user-friendly messages
- [ ] Progress indication during bulk upload

**Potential Issue**: `loadPeopleFromContent()` may batch people locally but not persist to server/AIMS properly.

**Fix**: Ensure `loadPeopleFromContent()` iterates each person through `addPersonWithSync()`:

```typescript
const loadPeopleFromContent = useCallback(async (csvContent: string): Promise<void> => {
    // Parse CSV
    const people = parsePeopleCSV(csvContent, ...);
    
    // Add each person with sync (sequential to handle POOL-ID reuse)
    const errors: string[] = [];
    for (const personData of people) {
        try {
            await addPersonWithSync(personData);
        } catch (error: any) {
            errors.push(`${personData.name || 'Unknown'}: ${error.message}`);
        }
    }
    
    if (errors.length > 0) {
        throw new Error(`Some people failed to sync:\n${errors.join('\n')}`);
    }
}, [...]);
```

---

### 2.8 Fix Unassign Space Behavior (Person Deletion Bug)

**Issue**: When unassigning a space from a person in People mode, the person is deleted from the table. However, the person should remain in the database even when not assigned to a space in AIMS.

**Expected Behavior**:
- Person with assigned space → Unassign → Person remains in DB with `assignedSpaceId = null`
- Person returns to their virtual pool ID (POOL-XXXX)
- Person data persists, only the space assignment is cleared
- In AIMS: The physical space article is cleared, person's POOL-ID article is updated

**Files to Investigate**:
- `usePeopleController.ts` - `unassignSpace()` or `removeSpaceAssignment()` method
- `peopleStore.ts` - Local state management for unassignment
- `peopleApi.ts` / `people/service.ts` - Backend unassign endpoint

**Fix Approach**:

```typescript
// usePeopleController.ts - unassignSpace method
const unassignSpace = useCallback(async (personId: string): Promise<void> => {
    const person = getStoreState().people.find(p => p.id === personId);
    if (!person) return;

    const oldSpaceId = person.assignedSpaceId;
    
    // 1. Clear the physical space in AIMS (if connected)
    if (settings.solumConfig?.tokens?.accessToken && oldSpaceId) {
        await clearSpaceInAims(oldSpaceId, person, ...);
    }
    
    // 2. Update local state - set assignedSpaceId to null, keep virtualSpaceId
    getStoreState().updatePersonLocal(personId, { 
        assignedSpaceId: null,  // Clear assignment
        // virtualSpaceId remains unchanged (person goes back to pool)
    });
    
    // 3. Update server - DO NOT DELETE, just update
    await getStoreState().updatePerson(personId, { 
        data: { ...person.data, assignedSpaceId: null }
    });
    
    // 4. Sync person's POOL-ID article back to AIMS with their data
    if (settings.solumConfig?.tokens?.accessToken) {
        await pushArticles(..., [{ 
            articleId: person.virtualSpaceId,  // POOL-XXXX
            ...person.data 
        }]);
    }
}, [...]);
```

**Verification Checklist**:
- [ ] Unassign updates `assignedSpaceId = null` instead of deleting person
- [ ] Person's `virtualSpaceId` (POOL-XXXX) is preserved
- [ ] Person remains visible in people table (unassigned section)
- [ ] Physical space article in AIMS is cleared
- [ ] Person's POOL-ID article in AIMS is updated with their data
- [ ] Server DB retains the person record

---

### 2.9 Validate List Management Schema

**Prisma Schema** (verified):

```prisma
model PeopleList {
  id          String   @id @default(uuid())
  storeId     String   @map("store_id")
  name        String   @db.VarChar(100)
  storageName String   @map("storage_name") @db.VarChar(100)
  createdById String?  @map("created_by")
  ...
  memberships PeopleListMembership[]
  
  @@unique([storeId, storageName])  // Ensures unique list names per store
}

model PeopleListMembership {
  id        String   @id @default(uuid())
  personId  String   @map("person_id")
  listId    String   @map("list_id")
  spaceId   String?  @map("space_id")   // Tracks space assignment within list
  ...
  
  @@unique([personId, listId])  // One person per list membership
}
```

**Schema Assessment**: ✅ Schema is correct

**API Endpoints** (from `peopleApi.ts`):
- `list(storeId)` - Get all lists for a store
- `getById(id)` - Get list with members
- `create(data)` - Create new list with optional memberIds
- `update(id, data)` - Update list name/description
- `delete(id)` - Delete list (cascades memberships)
- `addMember(id, personId)` / `removeMember(id, personId)`

**Verification Checklist**:
- [ ] Lists sync to AIMS via `_LIST_MEMBERSHIPS_` field
- [ ] Creating a list updates person's `data._LIST_MEMBERSHIPS_`
- [ ] Deleting a list removes from person's memberships
- [ ] List CRUD operations are properly authorized per store

---

## Section 3: Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| AIMS sync fails silently | Data loss | Implement detailed error logging + UI feedback |
| Rollback deletes person user just created | User confusion | Clear error message explaining what happened |
| Periodic verification causes load | Performance | Rate limit, batch processing, off-peak scheduling |
| CSV upload with 1000+ rows | Timeout | Batch uploads, progress indicator, background job |
| Concurrent edits during sync | Race conditions | Database transactions, optimistic locking |
| Unassign deletes person unexpectedly | Data loss | Fix to update assignment only, not delete |

---

## Section 4: Implementation Order

### Phase 1: Foundation (Day 1)
1. Add `syncErrorLogger.ts` for detailed error tracking
2. Update backend services with rollback logic
3. Add comprehensive error logging

### Phase 2: Frontend Cleanup (Day 1-2)
4. Remove `postToAims` checkbox from `PersonDialog.tsx`
5. Remove `postToAims` parameters from controller methods
6. Remove "Send All to AIMS" button from toolbars
7. **Fix unassign space behavior** - Person should remain in DB when unassigned

### Phase 3: Periodic Verification (Day 2-3)
8. Create `AimsVerificationJob.ts`
9. Integrate with server startup
10. Add admin endpoint to trigger manual verification

### Phase 4: CSV & Lists (Day 3)
11. Verify CSV upload flow end-to-end
12. Fix any issues with bulk person sync
13. Validate list management CRUD operations

### Phase 5: Testing (Day 3-4)
14. Update/create unit tests for new rollback logic
15. Integration tests for full sync flow
16. E2E tests for CSV upload and list management
17. **Test unassign flow** - verify person persists after unassignment

---

## Section 5: Testing Strategy

### Unit Tests
- `syncErrorLogger.test.ts` - Verify error logging works
- `usePeopleController.test.ts` - Test rollback on AIMS failure
- `AimsVerificationJob.test.ts` - Test drift detection

### Integration Tests
- Create person → verify in DB and AIMS
- Create person → AIMS fails → verify rollback
- CSV upload → verify all people synced
- List create → verify memberships synced
- **Unassign space → verify person remains in DB with null assignment**
- **Unassign space → verify POOL-ID article updated in AIMS**

### E2E Tests
- Full workflow: Add person via dialog → appears in AIMS
- Full workflow: CSV upload → all people in AIMS
- Full workflow: Create list → assign people → memberships in AIMS

---

## Section 6: Rollback Plan

If issues arise post-deployment:

1. **Revert to opt-in sync**: Re-add `postToAims` checkbox with default `true`
2. **Disable verification job**: Set flag or remove from startup
3. **Restore "Send All" button**: User can manually batch sync
4. **Database restore**: If data corruption, restore from backup

---

## Section 7: Files to Modify

### Frontend
| File | Changes |
|------|---------|
| `PersonDialog.tsx` | Remove `postToAims` state and checkbox |
| `usePeopleController.ts` | Remove `postToAims` params, add rollback, **fix unassign logic** |
| `peopleStore.ts` | **Fix unassign to update (not delete) person** |
| `PeopleToolbar.tsx` | Remove "Send All to AIMS" button |
| `PeopleAimsActionsBar.tsx` | Remove "Send All to AIMS" button |
| `PeopleManagerView.tsx` | Remove `onSendAllToAims` handler |
| `CSVUploadDialog.tsx` | Verify sync flow |

### Backend
| File | Changes |
|------|---------|
| `people/service.ts` | Add rollback logic, blocking sync option |
| `conference/service.ts` | Add rollback logic |
| `syncErrorLogger.ts` | NEW - Error logging service |
| `AimsVerificationJob.ts` | NEW - Periodic verification |
| `index.ts` | Register verification job |

### Locale Files
| File | Changes |
|------|---------|
| `en/common.json` | Add error messages for rollback scenarios |
| `he/common.json` | Add Hebrew translations |

---

## Appendix A: API Response Codes

| Code | Meaning | Frontend Action |
|------|---------|-----------------|
| 200 | Success | Show success toast |
| 409 | Conflict (duplicate) | Show "already exists" error |
| 422 | AIMS sync failed | Show "sync failed, not saved" error |
| 500 | Server error | Show "please try again" error |

---

## Appendix B: Monitoring & Alerts

### Metrics to Track
- Sync queue depth (should stay near 0)
- Sync failure rate
- AIMS verification drift count
- Rollback frequency

### Alert Thresholds
- Sync queue > 100 items for 5+ minutes
- Sync failure rate > 5% in 15 minutes
- Drift count > 10 entities in single verification

---

*End of Implementation Plan*
